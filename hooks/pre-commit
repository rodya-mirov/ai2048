#!/usr/bin/env bash

git commit -m "TEMP" --no-verify    # Makes a temp commit of all staged changes (skipping hooks, obviously)

# Check if we have anything left, including untracked files. If there are, rig up a trap to stash them at the end.
# If not, don't have any meaningful trap (no-op). This is needed because there is no nice programmatic way to
# distinguish between "stash made" and "stash not made because there are no changes."
if [ -z "$(git status --porcelain=v1 2>/dev/null)" ]
then
  function undo_setup()
  {
    # nothing to stash, nothing to pop; leaving this no-op in here to make bash happy
    true
  }
else
  function undo_setup()
  {
    git restore . > /dev/null     # Drops any changes made by the commit hook; this should only be relevant if the hook failed
    git stash pop > /dev/null     # Gives back the unstaged / untracked changes
  }
fi
trap undo_setup EXIT # this will trigger if the script errors OR has a happy exit

git stash -u                        # Stashes every change (which is just anything that was unstaged or untracked before)
git reset --soft HEAD^              # Deletes the TEMP commit and rolls back to the pre-commited state, so everything is still added

set -e

echo "== Running pre-commit scripts ==="

echo "Running code formatter (workspace)"
cargo +nightly fmt --all

if [[ ${GIT_VENV} ]] ; then
  echo "Activating venv at" "${GIT_VENV}/bin/activate"
  source "${GIT_VENV}/bin/activate"
  PYTHON_CMD="python"
else
  echo "Using base python3 for pre-commit script; to use a virtualenv, set the GIT_VENV variable"
  echo "For instance, export GIT_VENV=venv; git commit -m \"feat: wip\""
  PYTHON_CMD="python3"
fi

echo "Running code formatter (import sorting)"
if ! $PYTHON_CMD -m ruff check --select=I --fix ; then
  echo "The linter failed; if it had strange errors, try installing dependencies locally. e.g.:"
  echo ">" $PYTHON_CMD "-m pip install --upgrade -r dev_requirements.txt"
  exit 1
fi

echo "Running code formatter"
if ! $PYTHON_CMD -m ruff format ; then
  echo "The linter failed; if it had strange errors, try installing dependencies locally. e.g.:"
  echo ">" $PYTHON_CMD "-m pip install --upgrade -r dev_requirements.txt"
  exit 1
fi

echo "Running code linter (does not block commit, but should be addressed before push)"
cargo clippy --workspace --tests || true

echo "Checking for unused dependencies (does not block commit, but should be addressed before push)"
cargo +nightly udeps --workspace || true

# For now, we don't lint the jobs themselves, because there are a large number of Magic Variables inserted by the
# spark runtime that ruff doesn't know about. We may address this at a later point.
$PYTHON_CMD -m ruff check verifier_tests || true

PATH=$PATH:/usr/local/bin:/usr/local/sbin

# formats any java code that is staged for commit according to the eclipse style file

# list of all java files staged for commit
files=$(git diff-index --diff-filter=d --cached --name-only HEAD | grep '.*\.java$' || echo '')

# Only run the script if java files have changed
if [ -n "${files}" ]; then
  # Run spotlessApply using the Gradle configuration cache.
  echo "Running spotlessApply"
  trap 'echo "${output}"' EXIT
  output="$(./gradlew --configuration-cache spotlessApply 2>&1)"
  if grep -q "Spotless JVM-local cache is stale" <<< "$output"; then
    trap - EXIT
    # https://github.com/diffplug/spotless/issues/987
    echo "> Spotless JVM-local cache is stale. Cleaning Gradle configuration cache and rerunning Spotless..."
    rm -rf .gradle/configuration-cache
    ./gradlew --configuration-cache spotlessApply
  else
    echo "$output"
    trap - EXIT
  fi
fi

if [ -n "$(git ls-files --modified)" ]; then
  git ls-files --modified | xargs -n 1 git add
fi
